'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint-disable no-console */

exports.default = shaven;

var _parseSugarString = require('./parseSugarString');

var _parseSugarString2 = _interopRequireDefault(_parseSugarString);

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _namespaceToURL = require('./namespaceToURL');

var _namespaceToURL2 = _interopRequireDefault(_namespaceToURL);

var _mapAttributeValue = require('./mapAttributeValue');

var _mapAttributeValue2 = _interopRequireDefault(_mapAttributeValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function shaven(arrayOrObject) {
  var isArray = Array.isArray(arrayOrObject);
  var objType = typeof arrayOrObject === 'undefined' ? 'undefined' : _typeof(arrayOrObject);

  if (!isArray && objType !== 'object') {
    throw new Error('Argument must be either an array or an object ' + 'and not ' + JSON.stringify(arrayOrObject));
  }

  if (isArray && arrayOrObject.length === 0) {
    // Ignore empty arrays
    return {};
  }

  var config = {};
  var elementArray = void 0;

  if (Array.isArray(arrayOrObject)) {
    elementArray = arrayOrObject;
  } else {
    elementArray = arrayOrObject.elementArray;
    delete arrayOrObject.elementArray;
    Object.assign(config, arrayOrObject);
  }

  config = Object.assign({}, _defaults2.default, config, {
    returnObject: { // Shaven object to return at last
      ids: {},
      references: {}
    }
  });

  config.nsStack = [config.namespace]; // Stack with current namespaces


  function createElement(sugarString) {
    var properties = (0, _parseSugarString2.default)(sugarString);
    var currentNs = config.nsStack[config.nsStack.length - 1];

    if (properties.tag === 'svg') {
      config.nsStack.push('svg');
    } else if (properties.tag === 'math') {
      config.nsStack.push('mathml');
    } else if (properties.tag === 'html') {
      config.nsStack.push('xhtml');
    } else {
      // Keep current namespace
      config.nsStack.push(currentNs);
    }

    var namespace = config.nsStack[config.nsStack.length - 1];
    var element = document.createElementNS(_namespaceToURL2.default[namespace] ? _namespaceToURL2.default[namespace] : namespace, properties.tag);

    if (properties.id) {
      element.id = properties.id;
      console.assert(!config.returnObject.ids.hasOwnProperty(properties.id), 'Ids must be unique and "' + properties.id + '" is already assigned');
      config.returnObject.ids[properties.id] = element;
    }
    if (properties.class) {
      var _element$classList;

      (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(properties.class.split(' ')));
    }
    if (properties.reference) {
      console.assert(!config.returnObject.ids.hasOwnProperty(properties.reference), 'References must be unique and "' + properties.id + '" is already assigned');
      config.returnObject.references[properties.reference] = element;
    }

    config.escapeHTML = properties.escapeHTML != null ? properties.escapeHTML : config.escapeHTML;

    return element;
  }

  function buildDom(array) {
    if (Array.isArray(array) && array.length === 0) {
      // Ignore empty arrays
      return {};
    }

    var index = 1;
    var createdCallback = void 0;

    if (typeof array[0] === 'string') {
      array[0] = createElement(array[0]);
    } else if (Array.isArray(array[0])) {
      index = 0;
    } else if (!(array[0] instanceof Element)) {
      throw new Error('First element of array must be either a string, ' + 'an array or a DOM element and not ' + JSON.stringify(array[0]));
    }

    // For each in the element array (except the first)
    for (; index < array.length; index++) {

      // Don't render element if value is false or null
      if (array[index] === false || array[index] === null) {
        array[0] = false;
        break;
      }

      // Continue with next array value if current is undefined or true
      else if (array[index] === undefined || array[index] === true) {
          continue;
        }

        // If is string has to be content so set it
        else if (typeof array[index] === 'string' || typeof array[index] === 'number') {
            if (config.escapeHTML) {
              array[0].appendChild(document.createTextNode(array[index]));
            } else {
              array[0].innerHTML = array[index];
            }
          }

          // If is array has to be child element
          else if (Array.isArray(array[index])) {
              // If is actually a sub-array, flatten it
              if (Array.isArray(array[index][0])) {
                array[index].reverse().forEach(function (subArray) {
                  // eslint-disable-line no-loop-func
                  array.splice(index + 1, 0, subArray);
                });

                if (index !== 0) continue;
                index++;
              }

              // Build dom recursively for all child elements
              buildDom(array[index]);

              // Append the element to its parent element
              if (array[index][0]) {
                array[0].appendChild(array[index][0]);
              }
            } else if (typeof array[index] === 'function') {
              createdCallback = array[index];
            }

            // If it is an element append it
            else if (array[index] instanceof Element) {
                array[0].appendChild(array[index]);
              }

              // Else must be an object with attributes
              else if (_typeof(array[index]) === 'object') {
                  // For each attribute
                  for (var attributeKey in array[index]) {
                    if (!array[index].hasOwnProperty(attributeKey)) continue;

                    var attributeValue = array[index][attributeKey];

                    if (array[index].hasOwnProperty(attributeKey) && attributeValue !== null && attributeValue !== false) {
                      array[0].setAttribute(attributeKey, (0, _mapAttributeValue2.default)(attributeKey, attributeValue, config));
                    }
                  }
                } else {
                  throw new TypeError('"' + array[index] + '" is not allowed as a value');
                }
    }

    config.nsStack.pop();

    // Return root element on index 0
    config.returnObject[0] = array[0];
    config.returnObject.rootElement = array[0];

    config.returnObject.toString = function () {
      return array[0].outerHTML;
    };

    if (createdCallback) createdCallback(array[0]);
  }

  buildDom(elementArray);

  return config.returnObject;
}

shaven.setDefaults = function (object) {
  Object.assign(_defaults2.default, object);
  return shaven;
};